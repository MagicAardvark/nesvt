[{"/app/src/index.js":"1","/app/src/App.js":"2","/app/src/reportWebVitals.js":"3","/app/src/components/Header.js":"4","/app/src/util.js":"5","/app/src/components/DriverClass.js":"6","/app/src/components/DriverClasses.js":"7","/app/src/components/Driver.js":"8","/app/src/components/Runs.js":"9","/app/src/components/SearchBar.js":"10","/app/src/components/ClassDropDown.js":"11","/app/src/components/SortByDropDown.js":"12","/app/src/components/SortBy.js":"13","/app/src/components/ResultsSorter.js":"14"},{"size":547,"mtime":1625015412160,"results":"15","hashOfConfig":"16"},{"size":2008,"mtime":1632694896874,"results":"17","hashOfConfig":"16"},{"size":362,"mtime":1624622197462,"results":"18","hashOfConfig":"16"},{"size":3692,"mtime":1632758478159,"results":"19","hashOfConfig":"16"},{"size":8667,"mtime":1632693755620,"results":"20","hashOfConfig":"16"},{"size":2160,"mtime":1629496143639,"results":"21","hashOfConfig":"16"},{"size":3218,"mtime":1629496143639,"results":"22","hashOfConfig":"16"},{"size":2873,"mtime":1632756292534,"results":"23","hashOfConfig":"16"},{"size":488,"mtime":1629496143639,"results":"24","hashOfConfig":"16"},{"size":2368,"mtime":1629496143639,"results":"25","hashOfConfig":"16"},{"size":2239,"mtime":1632757897294,"results":"26","hashOfConfig":"16"},{"size":1369,"mtime":1632757780635,"results":"27","hashOfConfig":"16"},{"size":102,"mtime":1632693755620,"results":"28","hashOfConfig":"16"},{"size":1826,"mtime":1632693755620,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"144mqka",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"32"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"/app/src/index.js",[],["60","61"],"/app/src/App.js",[],"/app/src/reportWebVitals.js",[],"/app/src/components/Header.js",[],"/app/src/util.js",["62"],"/**\n * \n    Pulled mapRow and parseTable from https://gist.github.com/WickyNilliams/9252235 and modified for our use.\n */\n\n/**\n * generates factory functions to convert table rows to objects,\n * based on the titles in the table's <thead>\n * @param  {Array<String>} headings the values of the table's <thead>\n * @return {(row: HTMLTableRowElement) => Object} a function that takes a table row and spits out an object\n */\nfunction mapRow(headings) {\n    return function mapRowToObject({ cells }) {\n        return [...cells].reduce(function(result, cell, i) {\n            const input = cell.querySelector(\"input,select\");\n            var value;\n\n            if (input) {\n                value = input.type === \"checkbox\" ? input.checked : input.value;\n            } else {\n                value = cell.innerText;\n            }\n\n            // this if statements exists solely for if there are extra rows without headings (because that crashes the app)\n            // the drivers that have extra rows will not show up in the results, but it doesn't crash so that's cool\n            if (headings[i]) {\n                return Object.assign(result, {\n                    [headings[i].replace(\" \", \"\")]: value\n                });\n            }\n        }, {});\n    };\n}\n\n/**\n * given a table, generate an array of objects.\n * each object corresponds to a row in the table.\n * each object's key/value pairs correspond to a column's heading and the row's value for that column\n *\n * @param  {HTMLTableElement} table the table to convert\n * @return {Array<Object>}       array of objects representing each row in the table\n */\nexport const parseTable = (table) => {\n    var headings = [...table.tBodies[0].rows[0].cells].map(\n        heading => heading.innerText\n    );\n\n    return [...table.tBodies[0].rows].map(mapRow(headings));\n}\n\nfunction getConeHits(entry) {\n\n    if (entry.includes(\"dnf\")) {\n        return 0\n    }\n\n    if (entry.includes(\"+\")) {\n        return parseInt(entry.split(\"+\")[1]);\n    } else {\n        return 0;\n    }\n}\n\nfunction getTime(entry) {\n    if (entry.includes(\"+\")) {\n        return entry.split(\"+\")[0]\n    } else {\n        return entry\n    }\n}\n\nfunction parseRuns(records, extended) {\n\n    var runs = []\n\n    for (let i = 0; i < Object.keys(records).length; i++) {\n\n        var key = Object.keys(records)[i]\n\n        if (key.includes(\"Run\")) {\n            var number = parseInt(key.replace(\"Run\", \"\").replace(\"..\", \"\"))\n            runs.push({\n                \"number\": number,\n                \"time\": getTime(records[key]).replace(/(\\r\\n|\\n|\\r)/gm, \"\").trim(),\n                \"dnf\": records[key].includes(\"dnf\"),\n                \"cones\": getConeHits(records[key]),\n                \"raw\": records[key]\n            })\n        }\n    }\n\n    for (let i = 0; i < Object.keys(extended).length; i++) {\n\n        key = Object.keys(extended)[i]\n\n        if (key.includes(\"Run\")) {\n            number = parseInt(key.replace(\"Run\", \"\").replace(\"..\", \"\"))\n            runs.push({\n                \"number\": number + 10,\n                \"time\": getTime(extended[key]),\n                \"dnf\": extended[key].includes(\"dnf\"),\n                \"cones\": getConeHits(extended[key]),\n                \"raw\": extended[key]\n            })\n        }\n    }\n\n    return runs\n}\n\nfunction parsePosition(pos) {\n    if (pos.includes(\"T\")) {\n        return parseInt(pos.replace(\"T\", \"\"));\n    } else {\n        return parseInt(pos);\n    }\n}\n\nfunction isTrophy(pos) {\n    return pos.includes(\"T\")\n}\n\nfunction getNextRow(data, i) {\n    if (i + 1 < data.length) {\n        return data[i + 1]\n    } else {\n        return null\n    }\n}\n\nconst getClassFullName = (shortName) => {\n    switch (shortName) {\n        case \"es\":\n            return \"Experienced Street\";\n        case \"er\":\n            return \"Experienced Race\";\n        case \"int\":\n            return \"Intermediate\";\n        case \"n\":\n            return \"Novice\";\n        case \"pony\":\n            return \"Pony Car\";\n        case \"fwd\":\n            return \"Wrong-Wheel Drive\";\n        case \"cst\":\n            return \"Corvette Street\";\n        case \"crt\":\n            return \"Corvette Race\";\n        case \"mzst\":\n            return \"Zoom Zoom\";\n        default:\n            return shortName;\n    }\n}\n\nexport const parseResults = (data) => {\n\n    // var results = [];\n    var results = {\n        class: {},\n        drivers: []\n    }\n\n    // start at 1 to because it's the table header, and because\n    // why not use the actual table head directive?\n    for (let i = 1; i < data.length; i++) {\n\n        var row = data[i];\n        // this if statement exists solely in case there are a bunch of rows without headers (which crashes the app)\n        // drivers with extra rows will not show up in the results because of this check. but the app doesn't crash!\n        if (!row) {\n            continue;\n        }\n\n        // because we're dealing with silly nonsense, the next row contains\n        // additional runs, but there is no indication it's included with this row.\n        var next_row = getNextRow(data, i)\n\n        // skip if table line break\n        // imagine how much less stupid this code would be if\n        // they used web concepts from the last 20 years?\n\n        if (!('Driver' in row)) {\n            continue;\n        }\n\n        var normalizedRuns = parseRuns(row, next_row)\n\n        var result = {\n            \"name\": row.Driver,\n            \"number\": row['#'],\n            \"class\": row.Class,\n            \"car\": row.CarModel,\n            \"runs\": normalizedRuns,\n            \"trophy\": isTrophy(row[\"Pos.\"]),\n            \"position\": parsePosition(row[\"Pos.\"]),\n            \"fastest\": actualTime(fastestRun(normalizedRuns))\n        }\n\n        // TODO: refactor\n        if (results.class.hasOwnProperty(row.Class)) {\n            results.class[row.Class].count = results.class[row.Class].count + 1\n        } else {\n            results.class[row.Class] = { count: 1, name: getClassFullName(row.Class), alias: row.Class }\n        }\n\n        // these are extra runs, skip for now\n        if (next_row) {\n            i++\n        }\n\n        results.drivers.push(result)\n\n    }\n    return results;\n}\n\nexport const displayRun = (run) => {\n\n    if (run.time === 999.999) {\n        return 'dns'\n    }\n\n    if (run.dnf) {\n        return `${run.time}+dnf`\n    }\n\n    if (run.cones > 0) {\n        return `${run.time}+${run.cones}`\n    }\n\n    return `${run.time}`\n}\n\nexport const actualTime = (run) => {\n\n    var penalty = 2.000\n\n    if (run.dnf) {\n        return 999.999\n    }\n\n    if (run.cones > 0) {\n        return parseFloat(run.time) + (run.cones * penalty)\n    }\n\n    return parseFloat(run.time)\n}\n\nexport const countRuns = (runs) => {\n    return runs.filter((run) => {\n        return run.time !== null && run.time !== ''\n    }).length\n}\n\nexport const latestRun = (runs) => {\n    runs = runs.filter((run) => {\n        return run.time !== null && run.time !== ''\n    })\n\n    if (runs.length === 0) {\n        return 'dns'\n    }\n    return displayRun(runs[runs.length - 1]);\n}\n\nexport const fastestRun = (runs) => {\n    var fastest = { time: 999.999, dnf: false, cones: 0 };\n    runs.forEach((run, index, runs) => {\n        if (actualTime(run) < actualTime(fastest) && !run.dnf) {\n            fastest = run;\n        }\n    })\n    return fastest\n}\n\nexport const initDoc = (body) => {\n    return (new DOMParser()).parseFromString(body, 'text/html');\n}\n\nexport const parseResultsFromHtml = (data) => {\n    var doc = initDoc(data)\n    const table = doc.querySelectorAll(\"table\")[3]\n    return parseResults(parseTable(table));\n}\n\nexport const sortByCarNumber = (a, b) => {\n    if (parseInt(a.number) < parseInt(b.number)) {\n        return -1\n    }\n\n    if (parseInt(a.number) > parseInt(b.number)) {\n        return 1\n    }\n\n    return 0\n}\n\nexport const sortByFastest = (a, b) => {\n    if (a.fastest < b.fastest) {\n        return -1\n    }\n\n    if (a.fastest > b.fastest) {\n        return 1\n    }\n\n    return 0\n}\n\n// eslint-disable-next-line\nconst fetchData = async() => {\n    const res = await fetch('results_sample.html');\n    const data = await res.text();\n    // console.log(results)\n    return parseResultsFromHtml(data);\n}\n\n\n// exec a func on component render\n// [results, setResults] = useState(() => {\n//   console.log('run func')\n//   return 4\n// })\n\n// useEffect(() => {\n//     fetch('url')\n//       .then(response => response.json())\n//       .then(json => console.log(json))\n// // eslint-disable-next-line \n// }, [results])\n\n// useEffect(() => {\n//     const getData = async() => {\n//         const data = await fetchData()\n//         setResults(data)\n//     }\n//     getData();\n// // eslint-disable-next-line \n// }, results)","/app/src/components/DriverClass.js",[],"/app/src/components/DriverClasses.js",[],"/app/src/components/Driver.js",[],"/app/src/components/Runs.js",[],"/app/src/components/SearchBar.js",[],"/app/src/components/ClassDropDown.js",[],"/app/src/components/SortByDropDown.js",["63"],"/app/src/components/SortBy.js",[],"/app/src/components/ResultsSorter.js",[],{"ruleId":"64","replacedBy":"65"},{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","severity":1,"message":"69","line":14,"column":34,"nodeType":"70","messageId":"71","endLine":14,"endColumn":42},{"ruleId":"72","severity":1,"message":"73","line":16,"column":13,"nodeType":"74","endLine":17,"endColumn":65},"no-native-reassign",["75"],"no-negated-in-lhs",["76"],"array-callback-return","Array.prototype.reduce() expects a value to be returned at the end of function.","FunctionExpression","expectedAtEnd","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-global-assign","no-unsafe-negation"]